<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<!-- PWA Settings -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Romeo Spelling">
<link rel="apple-touch-icon" href="https://img.icons8.com/color/180/lego-head.png">
<!-- Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Rounded+Mplus+1c:wght@400;800&display=swap" rel="stylesheet">

<title>Romeo's Spelling</title>
<style>
  :root {
    --bg: #f2f6fa; --card: #ffffff; --primary: #007AFF; 
    --lego-yellow: #FFCF00; --lego-red: #ff3b30; --text: #1d1d1f;
    --success: #34C759;
  }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  body {
    margin: 0; padding: 0; 
    font-family: "Rounded Mplus 1c", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
    background: var(--bg); color: var(--text);
    height: 100vh; display: flex; flex-direction: column;
    overflow: hidden; 
  }

  /* --- Layout --- */
  header {
    background: rgba(255,255,255,0.92);
    padding: 15px 20px; padding-top: max(15px, env(safe-area-inset-top));
    display: flex; align-items: center; justify-content: space-between;
    position: sticky; top: 0; z-index: 10; backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(0,0,0,0.05);
  }
  .brand { display: flex; align-items: center; gap: 12px; }
  .avatar {
    width: 44px; height: 44px; background: var(--lego-yellow);
    border-radius: 12px; display: flex; align-items: center; justify-content: center;
    font-weight: 900; font-size: 24px; color: #333;
    box-shadow: 0 4px 0 rgba(0,0,0,0.1); font-family: 'Fredoka One', cursive;
  }
  h1 { margin: 0; font-size: 20px; color: #000; letter-spacing: -0.5px; font-weight: 800; }
  .subtitle { font-size: 12px; color: #888; font-weight: 500; }

  /* --- Main Container --- */
  #app {
    flex: 1; overflow-y: auto; padding: 20px;
    padding-bottom: max(30px, env(safe-area-inset-bottom));
  }

  /* --- Artistic Text --- */
  .art-font { font-family: 'Fredoka One', cursive; letter-spacing: 1px; }
  
  /* --- Components --- */
  .card {
    background: var(--card); border-radius: 20px; padding: 24px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.04); margin-bottom: 20px;
  }
  
  /* Buttons */
  .btn {
    display: flex; align-items: center; justify-content: center; gap: 10px;
    width: 100%; padding: 18px; 
    border: none; border-radius: 16px;
    font-size: 18px; font-weight: 700; cursor: pointer;
    margin-bottom: 14px; transition: transform 0.1s;
    text-align: center;
    box-shadow: 0 4px 0 rgba(0,0,0,0.05);
    font-family: "Rounded Mplus 1c", sans-serif;
  }
  .btn:active { transform: scale(0.98) translateY(2px); box-shadow: none; }
  
  .btn-primary { background: var(--primary); color: #fff; box-shadow: 0 4px 0 #005bb5; }
  .btn-yellow { background: var(--lego-yellow); color: #000; box-shadow: 0 4px 0 #d4ac00; }
  .btn-green { background: var(--success); color: #fff; box-shadow: 0 4px 0 #248a3d; }
  .btn-outline { background: #fff; color: var(--primary); border: 2px solid #eef2f6; box-shadow: none; }
  
  .btn-row { display: flex; gap: 12px; margin-top: 10px; }
  .btn-small {
    flex: 1; padding: 12px; font-size: 14px; border-radius: 12px;
    background: #f1f3f7; color: #666; border: none; font-weight: 600;
  }

  /* --- Practice Mode UI --- */
  .word-display {
    text-align: center; margin: 20px 0;
    min-height: 120px; display: flex; flex-direction: column; justify-content: center;
  }
  .word-text { font-size: 52px; font-weight: 800; font-family: "Courier New", monospace; letter-spacing: 2px; }
  .phonics { font-size: 26px; color: #555; margin-top: 8px; font-weight: 700; background:#e3f2fd; color:#1565c0; display:inline-block; padding:6px 16px; border-radius:20px; margin: 10px auto 0; font-family: "Rounded Mplus 1c", sans-serif;}
  
  .blanks-container {
    display: flex; justify-content: center; flex-wrap: wrap; gap: 8px;
    margin: 30px 0; cursor: text;
  }
  .blank-char {
    width: 48px; height: 58px;
    border-bottom: 4px solid #e0e0e0;
    font-size: 36px; font-weight: bold;
    display: flex; align-items: center; justify-content: center;
    background: #fff; color: #333; border-radius: 8px;
    transition: all 0.2s;
  }
  .blank-char.active { border-bottom-color: var(--primary); background: #f0f7ff; transform: translateY(-2px); }
  .blank-char.filled { border-bottom-color: #333; }
  .blank-char.correct { color: #fff; background: var(--success); border-bottom-color: var(--success); border:none; }
  .blank-char.wrong { color: #fff; background: var(--lego-red); border-bottom-color: var(--lego-red); border:none; }

  /* --- Achievement Page --- */
  .rocket-stage {
    background: linear-gradient(135deg, #0b1e3b, #1a3a6c); color: #fff; border-radius: 20px; padding: 30px 20px;
    text-align: center; margin-bottom: 20px; position: relative; overflow: hidden;
  }
  .big-score { font-size: 56px; font-weight: 900; margin: 10px 0; text-shadow: 0 4px 10px rgba(0,0,0,0.3); font-family: 'Fredoka One', cursive; }
  .icons-grid { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; margin-top: 15px; font-size: 24px; }
  
  .history-item {
    background: #fff; border-radius: 14px; margin-bottom: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.02); overflow: hidden;
  }
  .history-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 16px; cursor: pointer;
  }
  .history-date { font-weight: 800; color: #333; }
  .history-count { color: #666; font-size: 14px; display: flex; align-items: center; gap: 6px; }
  .history-details {
    padding: 0 16px 16px 16px; display: none; border-top: 1px solid #f0f0f0;
  }
  .history-details.show { display: block; }
  .detail-tag {
    display: inline-block; background: #e8f5e9; color: #2e7d32; 
    padding: 4px 8px; border-radius: 6px; font-size: 13px; margin: 8px 4px 0 0; font-weight: bold;
  }
  
  /* Word Wall */
  .word-wall { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 10px; }
  .wall-item { background: #fff; border: 1px solid #eee; padding: 6px 10px; border-radius: 8px; font-size: 14px; font-weight: bold; color: #444; }

  /* --- Hidden Inputs --- */
  #hiddenInput { position: fixed; top: -100px; left: 0; opacity: 0; font-size: 16px; }
  #fileInput { display: none; }

  /* --- Overlay --- */
  #startOverlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(255,255,255,0.98); z-index: 100;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  textarea { width: 100%; border: 2px solid #e0e0e0; border-radius: 12px; padding: 14px; font-size: 16px; background: #fff; transition: border 0.2s;}
  textarea:focus { border-color: var(--primary); outline: none; }
</style>
</head>
<body>

<!-- Hidden Inputs -->
<input type="text" id="hiddenInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
<input type="file" id="fileInput" accept=".json" onchange="importData(this)">

<!-- Header -->
<header>
  <div class="brand">
    <div class="avatar">R</div>
    <div>
      <h1>Romeo's Spelling</h1>
      <div class="subtitle">Phonics & Fun</div>
    </div>
  </div>
  <div id="headerBtn"></div>
</header>

<!-- App Content -->
<div id="app"></div>

<!-- iOS Audio Unlock Overlay -->
<div id="startOverlay">
  <div class="avatar" style="width:100px;height:100px;font-size:50px;margin-bottom:24px;box-shadow:0 12px 24px rgba(0,0,0,0.15)">R</div>
  <h2 class="art-font" style="margin-bottom:8px;font-size:28px">Ready?</h2>
  <p style="color:#888;margin-bottom:32px">ç‚¹å‡»å¼€å§‹ä»¥å¯ç”¨å£°éŸ³</p>
  <button class="btn btn-primary" style="width:220px" onclick="unlockAudio()">ğŸš€ LET'S GO</button>
</div>

<script>
// --- 1. Global State & DB ---
let db;
let currentSetDate = null;
let practiceList = []; // Full list of current set
let currentIndex = 0;
let stage = 1; // 1:è®¤è¯»(First View), 2:å¬å†™(Dictation), 3:è®¢æ­£(Correction)
let wrongList = []; // Words wrong in Stage 2
let sessionMasteredSet = new Set(); // Words correctly spelled in Stage 2 or 3
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSuccessTone() {
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(500, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 0.1);
  gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.5);
}

// --- 2. Database Init (V4) ---
const DB_REQ = indexedDB.open('romeo_spelling_v4', 1);

DB_REQ.onupgradeneeded = (e) => {
  db = e.target.result;
  if (!db.objectStoreNames.contains('wordSets')) db.createObjectStore('wordSets', { keyPath: 'date' });
  if (!db.objectStoreNames.contains('wrongBank')) db.createObjectStore('wrongBank', { keyPath: 'word' });
  if (!db.objectStoreNames.contains('practiceLogs')) db.createObjectStore('practiceLogs', { keyPath: 'id', autoIncrement: true });
};
DB_REQ.onsuccess = (e) => { db = e.target.result; };
DB_REQ.onerror = (e) => console.error("DB Error", e);

// --- 3. Navigation & Views ---
const app = document.getElementById('app');
const headerBtn = document.getElementById('headerBtn');

function unlockAudio() {
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const u = new SpeechSynthesisUtterance('');
  speechSynthesis.speak(u);
  document.getElementById('startOverlay').style.display = 'none';
  renderHome();
}

// --- PAGE: HOME ---
function renderHome() {
  headerBtn.innerHTML = '';
  app.innerHTML = `
    <div style="margin-top:20px;text-align:center;margin-bottom:30px">
        <div class="art-font" style="font-size:48px;color:#333;text-shadow:2px 2px 0px #eee;margin-bottom:10px">Hi, Romeo!</div>
        <div style="font-size:16px;color:#666;font-weight:600">ä»Šå¤©æƒ³åšç‚¹ä»€ä¹ˆï¼Ÿ</div>
    </div>

    <button class="btn btn-primary" onclick="renderSetSelection()">
      <span style="font-size:24px">ğŸš€</span> å¼€å§‹ç»ƒä¹ 
    </button>
    
    <button class="btn btn-yellow" onclick="renderRecords()">
      <span style="font-size:24px">ğŸ†</span> æˆå°± & è®°å½•
    </button>
    
    <button class="btn btn-outline" onclick="renderInput()">
      <span style="font-size:24px">âœï¸</span> å½•å…¥æ–°è¯
    </button>

    <div class="card" style="margin-top:30px;background:#fff">
      <h4 style="margin:0 0 10px 0;color:#888;font-size:12px">DATA BACKUP</h4>
      <div class="btn-row">
         <button class="btn-small" onclick="exportAllData()">ğŸ“¤ å¯¼å‡ºå¤‡ä»½</button>
         <button class="btn-small" onclick="document.getElementById('fileInput').click()">ğŸ“¥ æ¢å¤æ•°æ®</button>
      </div>
    </div>
  `;
}

// --- PAGE: SET SELECTION ---
function renderSetSelection() {
  headerBtn.innerHTML = `<button class="btn-small" onclick="renderHome()">ğŸ  é¦–é¡µ</button>`;
  
  const tx = db.transaction(['wordSets', 'wrongBank'], 'readonly');
  Promise.all([getAll(tx.objectStore('wordSets')), getAll(tx.objectStore('wrongBank'))])
  .then(([sets, wrongs]) => {
    sets.sort((a,b) => b.date.localeCompare(a.date));
    
    let html = `
      <div style="margin-bottom:15px;display:flex;justify-content:space-between;align-items:center">
        <h3 style="margin:0">é€‰æ‹©è¯¾ç¨‹</h3>
        <span style="background:#eef;padding:4px 10px;border-radius:12px;font-size:12px;color:#558;font-weight:bold">${sets.length} ä¸ªä»»åŠ¡</span>
      </div>
    `;
    
    if(wrongs.length > 0) {
      html += `
        <button class="btn btn-red" style="background:#ffebee;color:#d32f2f;box-shadow:none;border:2px solid #ffcdd2" onclick="renderWrongPractice()">
          ğŸ”¥ é”™é¢˜çªå‡» (${wrongs.length} è¯)
        </button>
        <div style="height:10px"></div>
      `;
    }

    if(sets.length === 0) {
      html += `<div style="text-align:center;padding:40px;color:#999">æš‚æ— ç»ƒä¹ ï¼Œå¿«å»å½•å…¥æ–°è¯å§ï¼</div>`;
    } else {
      html += sets.map(s => {
          // Display cleaned words in list (remove slashes)
          const previewWords = s.words.map(w => w.replace(/[\/\-]/g, '')).slice(0,5).join(', ');
          return `
            <div class="set-item" style="display:flex;justify-content:space-between;align-items:center;padding:16px;background:#fff;border-radius:12px;margin-bottom:10px;box-shadow:0 2px 5px rgba(0,0,0,0.02)" onclick="startPractice('${s.date}')">
              <div class="set-info">
                <strong style="font-size:17px;color:#333">ğŸ“… ${s.date}</strong>
                <span style="font-size:13px;color:#888">${previewWords}${s.words.length>5?'...':''}</span>
              </div>
              <div style="font-weight:bold;color:var(--primary);background:#eef6ff;padding:6px 12px;border-radius:10px">${s.words.length}è¯ â€º</div>
            </div>
          `;
      }).join('');
    }
    app.innerHTML = html;
  });
}

// --- PAGE: RECORDS / ACHIEVEMENTS ---
function renderRecords() {
  headerBtn.innerHTML = `<button class="btn-small" onclick="renderHome()">ğŸ  é¦–é¡µ</button>`;
  
  const tx = db.transaction('practiceLogs', 'readonly');
  getAll(tx.objectStore('practiceLogs')).then(logs => {
    logs.sort((a,b) => b.timestamp - a.timestamp);
    
    // Stats calculation
    let totalStars = 0;
    let allMasteredWords = new Set();

    logs.forEach(l => {
        totalStars += l.count;
        if(l.words && Array.isArray(l.words)) {
            l.words.forEach(w => allMasteredWords.add(w.toLowerCase()));
        }
    });
    
    const rockets = Math.floor(totalStars / 10);
    const currentStars = totalStars % 10;
    
    // Icons
    let rocketsHtml = '';
    for(let i=0; i<rockets; i++) rocketsHtml += 'ğŸš€ ';
    if(rockets === 0) rocketsHtml = '<span style="font-size:14px;opacity:0.6;font-weight:normal">åŠ æ²¹ç»ƒä¹ èµšå–ç«ç®­ï¼</span>';
    
    let starsHtml = '';
    for(let i=0; i<currentStars; i++) starsHtml += 'â­ ';
    for(let i=currentStars; i<10; i++) starsHtml += '<span style="opacity:0.2">â­</span> ';

    // History List
    let historyHtml = logs.length === 0 ? '<div style="text-align:center;padding:20px;color:#999">æš‚æ— è®°å½•</div>' : '';
    
    logs.forEach((log, index) => {
        const wordsArr = log.words || [];
        const wordsHtml = wordsArr.map(w => `<span class="detail-tag">${w}</span>`).join('');
        
        historyHtml += `
            <div class="history-item">
                <div class="history-header" onclick="toggleHistory(${index})">
                    <div>
                        <div class="history-date">${log.date}</div>
                        <div class="history-count">
                           <span>å®Œæˆ ${log.count} ä¸ªå•è¯</span>
                           <span style="font-size:10px;color:#999">â–¼</span>
                        </div>
                    </div>
                    <div style="font-weight:bold;color:#fbc02d">â­ +${log.count}</div>
                </div>
                <div class="history-details" id="hist-detail-${index}">
                    ${wordsHtml || '<span style="font-size:12px;color:#ccc">æ— è¯¦ç»†è®°å½•</span>'}
                </div>
            </div>
        `;
    });
    
    // Word Wall HTML
    const wallHtml = Array.from(allMasteredWords).sort().map(w => `<div class="wall-item">${w}</div>`).join('');

    app.innerHTML = `
      <div class="rocket-stage">
        <div style="position:relative;z-index:2">
            <div style="font-size:14px;opacity:0.8;text-transform:uppercase;letter-spacing:1px">Total Score</div>
            <div class="big-score">${totalStars}</div>
            <div style="background:rgba(255,255,255,0.1);border-radius:12px;padding:15px;margin-top:10px">
                <div style="font-size:12px;margin-bottom:5px;opacity:0.7">ç«ç®­æ”¶è—é¦† (${rockets})</div>
                <div class="icons-grid" style="font-size:20px">${rocketsHtml}</div>
            </div>
             <div style="background:rgba(255,255,255,0.1);border-radius:12px;padding:15px;margin-top:10px">
                <div style="font-size:12px;margin-bottom:5px;opacity:0.7">å½“å‰è¿›åº¦ (${currentStars}/10)</div>
                <div class="icons-grid">${starsHtml}</div>
            </div>
        </div>
      </div>
      
      <div class="card">
        <h3 style="margin:0 0 10px 0">å•è¯å¢™ (${allMasteredWords.size})</h3>
        <div class="word-wall">${wallHtml || '<span style="color:#999;font-size:13px">è¿˜æ²¡æœ‰æŒæ¡å•è¯å“¦</span>'}</div>
      </div>

      <h3 style="margin-left:5px;margin-top:20px">ç»ƒä¹ è¶³è¿¹</h3>
      <div class="history-list">
        ${historyHtml}
      </div>
    `;
  });
}

function toggleHistory(idx) {
    const el = document.getElementById(`hist-detail-${idx}`);
    if(el) {
        if(el.classList.contains('show')) el.classList.remove('show');
        else el.classList.add('show');
    }
}

// --- PAGE: INPUT ---
function renderInput() {
  headerBtn.innerHTML = `<button class="btn-small" onclick="renderHome()">ğŸ  é¦–é¡µ</button>`;
  const today = new Date().toISOString().slice(0, 10);
  app.innerHTML = `
    <div class="card">
      <h3 style="margin-top:0">å½•å…¥æ–°è¯</h3>
      <div style="background:#e3f2fd;padding:10px;border-radius:8px;font-size:12px;color:#1565c0;margin-bottom:10px">
        ğŸ’¡ <b>æç¤ºï¼š</b> å¦‚æœæƒ³æŒ‡å®šåˆ†éŸ³èŠ‚ï¼Œè¯·ç”¨ "/" æˆ– "-" éš”å¼€ã€‚<br>ä¾‹å¦‚ï¼š<code>el/e/phant</code> æˆ– <code>ba-na-na</code>
      </div>
      <label class="subtitle">æ—¥æœŸ</label>
      <input type="date" id="newDate" value="${today}" style="width:100%;padding:12px;border:2px solid #e0e0e0;border-radius:12px;margin:8px 0 16px;background:#fff">
      
      <label class="subtitle">å•è¯åˆ—è¡¨ (æ¯è¡Œä¸€ä¸ª)</label>
      <textarea id="newWords" rows="8" placeholder="ä¾‹å¦‚ï¼š&#10;ap/ple&#10;ba/na/na&#10;hap/py"></textarea>
      
      <div style="margin-top:20px">
        <button class="btn btn-primary" onclick="saveSet()">ğŸ’¾ ä¿å­˜è¯è¡¨</button>
        <button class="btn btn-outline" style="color:#d32f2f;border-color:#ffcdd2" onclick="deleteSetByDate()">ğŸ—‘ï¸ åˆ é™¤è¯¥æ—¥è¯è¡¨</button>
      </div>
    </div>
  `;
}

// --- LOGIC: SAVE/IMPORT/EXPORT ---
function saveSet() {
  const date = document.getElementById('newDate').value;
  const text = document.getElementById('newWords').value;
  if(!text.trim()) return alert("è¯·è¾“å…¥å•è¯");
  const words = text.split(/\n+/).map(w => w.trim()).filter(w => w);
  const tx = db.transaction('wordSets', 'readwrite');
  tx.objectStore('wordSets').put({ date, words });
  tx.oncomplete = () => { alert("ä¿å­˜æˆåŠŸ!"); renderSetSelection(); };
}

function deleteSetByDate() {
  const date = document.getElementById('newDate').value;
  if(!confirm(`ç¡®è®¤åˆ é™¤ ${date} çš„æ‰€æœ‰å•è¯å—ï¼Ÿ`)) return;
  const tx = db.transaction('wordSets', 'readwrite');
  tx.objectStore('wordSets').delete(date);
  tx.oncomplete = () => { alert("å·²åˆ é™¤"); renderSetSelection(); };
}

function exportAllData() {
  const tx = db.transaction(['wordSets', 'wrongBank', 'practiceLogs'], 'readonly');
  Promise.all([
    getAll(tx.objectStore('wordSets')), 
    getAll(tx.objectStore('wrongBank')),
    getAll(tx.objectStore('practiceLogs'))
  ])
  .then(([sets, wrongs, logs]) => {
      const data = { wordSets: sets, wrongBank: wrongs, practiceLogs: logs, exportDate: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `romeo_backup_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
  });
}

function importData(inputElement) {
  const file = inputElement.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      if (!data.wordSets && !data.wrongBank) throw new Error("Format error");
      const tx = db.transaction(['wordSets', 'wrongBank', 'practiceLogs'], 'readwrite');
      if(data.wordSets) data.wordSets.forEach(s => tx.objectStore('wordSets').put(s));
      if(data.wrongBank) data.wrongBank.forEach(w => tx.objectStore('wrongBank').put(w));
      if(data.practiceLogs) data.practiceLogs.forEach(l => tx.objectStore('practiceLogs').put(l));
      tx.oncomplete = () => { alert("æ¢å¤æˆåŠŸï¼"); renderHome(); inputElement.value = ''; };
    } catch (err) { alert("æ–‡ä»¶é”™è¯¯"); }
  };
  reader.readAsText(file);
}

// --- LOGIC: PRACTICE CORE ---
function startPractice(date) {
  const tx = db.transaction('wordSets', 'readonly');
  tx.objectStore('wordSets').get(date).onsuccess = (e) => {
    const data = e.target.result;
    if(!data) return;
    currentSetDate = date;
    practiceList = data.words;
    currentIndex = 0;
    stage = 1; wrongList = []; sessionMasteredSet = new Set();
    renderPracticeUI();
  };
}

function renderWrongPractice() {
  const tx = db.transaction('wrongBank', 'readonly');
  getAll(tx.objectStore('wrongBank')).then(list => {
    if(list.length === 0) return alert("é”™é¢˜æœ¬æ˜¯ç©ºçš„ï¼");
    currentSetDate = 'wrong_bank';
    practiceList = list.map(i => i.word);
    currentIndex = 0;
    stage = 2; wrongList = []; sessionMasteredSet = new Set();
    renderPracticeUI();
  });
}

function renderPracticeUI() {
  headerBtn.innerHTML = `<button class="btn-small" onclick="if(confirm('é€€å‡ºç»ƒä¹ ï¼Ÿ')) renderHome()">ğŸƒ é€€å‡º</button>`;
  let title = stage === 1 ? "ç¬¬ä¸€è½®: è®¤è¯»è®°å¿†" : (stage === 2 ? "ç¬¬äºŒè½®: å¬å†™è€ƒæ ¸" : "é”™é¢˜é‡ç»ƒ");
  if(currentSetDate === 'wrong_bank') title = "é”™é¢˜çªå‡»";
  
  app.innerHTML = `
    <div style="text-align:center;margin-bottom:15px;color:#888;font-weight:600;font-size:14px">
        ${title} â€¢ <span style="color:var(--primary)">${currentIndex + 1} / ${practiceList.length}</span>
    </div>
    <div class="card" id="practiceCard" style="min-height:300px"></div>
  `;
  loadWord();
}

function loadWord() {
  if(currentIndex >= practiceList.length) { handleRoundComplete(); return; }
  
  // Raw word might contain / or -
  const rawWord = practiceList[currentIndex];
  const cleanWord = rawWord.replace(/[\/\-]/g, ''); // For logic checking
  
  const container = document.getElementById('practiceCard');
  
  // Phonics Display: If manual / exists, use it. Else calculate.
  let phonicsDisplay = "";
  if(stage === 1) {
      if(rawWord.includes('/') || rawWord.includes('-')) {
          // Use manual entry but replace separators with dot
          phonicsDisplay = rawWord.replace(/[\/\-]/g, ' Â· ');
      } else {
          phonicsDisplay = getImprovedPhonics(cleanWord);
      }
  }

  const displayWord = stage === 1 ? cleanWord : "???";
  
  container.innerHTML = `
    <div class="word-display">
        <div class="word-text" style="color:${stage===1?'#333':'#ccc'}">${displayWord}</div>
        ${phonicsDisplay ? `<div class="phonics">${phonicsDisplay}</div>` : '<div style="height:38px"></div>'}
    </div>
    
    <div style="text-align:center;margin-bottom:20px">
        <button class="btn-outline" style="display:inline-flex;width:auto;padding:10px 20px;border-radius:30px;align-items:center;gap:5px" onclick="speak('${cleanWord}')">
            <span>ğŸ”Š</span> <span style="font-weight:bold">å¬å‘éŸ³</span>
        </button>
    </div>

    <div class="blanks-container" id="blanksArea"></div>
    <div style="text-align:center;height:30px;margin-bottom:10px;font-weight:bold;font-size:18px" id="feedback"></div>

    <button class="btn btn-primary" id="confirmBtn" onclick="checkWord()">âœ¨ ç¡®è®¤ (Enter)</button>
    <button class="btn btn-outline" id="skipBtn" style="margin-top:0;border:none;color:#999" onclick="skipWord()">è·³è¿‡ â€º</button>
  `;
  setupInput(cleanWord);
  setTimeout(() => speak(cleanWord), 400);
}

// --- LOGIC: INPUT & CHECK ---
let targetWord = "";
let currentInput = "";

function setupInput(word) {
  targetWord = word; currentInput = "";
  const blanks = document.getElementById('blanksArea'); blanks.innerHTML = '';
  for(let i=0; i<word.length; i++) {
    const b = document.createElement('div'); b.className = 'blank-char';
    if(word[i] === ' ' || word[i] === '-') { b.textContent = word[i]; b.style.borderBottom = 'none'; }
    blanks.appendChild(b);
  }
  const hidden = document.getElementById('hiddenInput');
  hidden.value = ''; hidden.focus();
  blanks.onclick = () => { hidden.focus(); updateBlanksUI(); };
  hidden.oninput = (e) => { 
      // Filter non-alpha
      let val = e.target.value.replace(/[^a-zA-Z]/g, '');
      currentInput = val.slice(0, targetWord.length); 
      updateBlanksUI(); 
  };
  hidden.onkeydown = (e) => { if(e.key === 'Enter') checkWord(); };
  updateBlanksUI();
}

function updateBlanksUI() {
  const chars = document.querySelectorAll('.blank-char');
  for(let i=0; i<targetWord.length; i++) {
    if(targetWord[i] === ' ' || targetWord[i] === '-') continue;
    const charElem = chars[i];
    const inputChar = currentInput[i] || '';
    charElem.textContent = inputChar;
    charElem.classList.remove('active', 'filled');
    if(i === currentInput.length) charElem.classList.add('active');
    if(inputChar) charElem.classList.add('filled');
  }
}

function checkWord() {
  const fb = document.getElementById('feedback');
  const cleanInput = currentInput.trim().toLowerCase();
  const cleanTarget = targetWord.trim().toLowerCase();
  
  if(!cleanInput) return; // Empty submission
  
  // Logic Branch
  if(cleanInput === cleanTarget) {
    // === CORRECT ===
    fb.innerHTML = `<span style="color:var(--success)">å¤ªæ£’äº†ï¼ğŸ‰</span>`;
    document.querySelectorAll('.blank-char').forEach(c => c.classList.add('correct'));
    playSuccessTone();

    // Stats Logic: Only count in Stage 2 (Dictation) or Stage 3 (Correction)
    if(stage >= 2) { 
        sessionMasteredSet.add(cleanTarget); // Use cleaned word for storage
        if(currentSetDate === 'wrong_bank') removeFromWrongBank(targetWord);
    }

    setTimeout(() => { currentIndex++; loadWord(); }, 800);

  } else {
    // === WRONG ===
    fb.innerHTML = `<span style="color:var(--lego-red)">æ­£ç¡®: ${targetWord}</span>`;
    document.querySelectorAll('.blank-char').forEach(c => c.classList.add('wrong'));
    const btn = document.getElementById('confirmBtn');

    if(stage === 1) {
        // Stage 1 Error: Clear and Retry
        btn.innerText = "è®°ä½äº† (æ¸…ç©ºé‡è¯•) â†º";
        btn.className = "btn btn-yellow";
        btn.onclick = () => {
            // Reset UI
            currentInput = "";
            document.getElementById('hiddenInput').value = "";
            updateBlanksUI();
            document.querySelectorAll('.blank-char').forEach(c => c.classList.remove('wrong'));
            fb.innerHTML = "";
            btn.innerText = "âœ¨ ç¡®è®¤ (Enter)";
            btn.className = "btn btn-primary";
            btn.onclick = checkWord;
            document.getElementById('hiddenInput').focus();
        };
        // NOTE: "Skip" button remains available in DOM
    } else {
        // Stage 2/3 Error: Add to Wrong List
        if(stage === 2) { 
            // Save raw word (keeping manual dividers if needed in future, but rawWord from list is safer)
            const rawW = practiceList[currentIndex];
            if(!wrongList.includes(rawW)) wrongList.push(rawW); 
            addToWrongBank(rawW); 
        }
        btn.innerText = "è®°ä½äº†ï¼Œç»§ç»­ â€º";
        btn.className = "btn btn-outline";
        btn.onclick = () => { currentIndex++; loadWord(); };
    }
  }
}

function skipWord() {
  // Stage 1 Skip: Just move on, doesn't count as wrong.
  currentIndex++; 
  loadWord(); 
}

function handleRoundComplete() {
  if(stage === 1) { 
    alert("ç¬¬ä¸€è½®è®°å¿†å®Œæˆï¼\nè¯·å‡†å¤‡å¥½ï¼Œæ¥ä¸‹æ¥å¼€å§‹å¬å†™æŒ‘æˆ˜ ğŸ’ª"); 
    stage = 2; currentIndex = 0; renderPracticeUI(); 
  } else if (stage === 2) {
    if(wrongList.length > 0) { 
      alert(`å¬å†™å®Œæˆï¼æœ‰ ${wrongList.length} ä¸ªå•è¯éœ€è¦è®¢æ­£ã€‚`); 
      practiceList = [...wrongList]; wrongList = []; stage = 3; currentIndex = 0; renderPracticeUI(); 
    } else {
      finishAll();
    }
  } else {
    // Stage 3 complete
    finishAll();
  }
}

function finishAll() {
  const masteredCount = sessionMasteredSet.size;
  
  if(masteredCount > 0) {
    const tx = db.transaction('practiceLogs', 'readwrite');
    tx.objectStore('practiceLogs').add({
        date: new Date().toISOString().slice(0,10),
        timestamp: Date.now(),
        count: masteredCount,
        words: Array.from(sessionMasteredSet), // Store specific words
        source: currentSetDate
    });
  }

  app.innerHTML = `
    <div class="card" style="text-align:center;padding:50px 20px;margin-top:40px">
      <div style="font-size:70px;margin-bottom:10px">ğŸš€</div>
      <h2 style="font-size:28px;margin-bottom:10px;color:#333;font-weight:800">ç»ƒä¹ å®Œæˆï¼</h2>
      <p style="color:#666;font-size:18px">æœ¬æ¬¡æŒæ¡: <b style="color:#fbc02d">${masteredCount} â­</b></p>
      <div style="height:20px"></div>
      <button class="btn btn-primary" onclick="renderHome()">è¿”å›é¦–é¡µ</button>
      <button class="btn btn-yellow" onclick="renderRecords()">æŸ¥çœ‹æˆå°±</button>
    </div>
  `;
}

// --- Helpers ---

// Improved Heuristic Phonics
function getImprovedPhonics(w) {
    const word = w.toLowerCase();
    
    // 1. Silent 'e' at end (makes previous vowel long, usually not a split)
    // E.g. "cake" -> cake, "late" -> late
    // But "table" -> ta-ble
    
    // Simple heuristic: VCV -> V-CV
    // VCCV -> VC-CV
    
    // We try to split by vowel groups
    // Regex for basic syllable chunks
    // This is still an approximation. English is hard.
    const chunks = word.match(/[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi);
    
    if(!chunks || chunks.length <= 1) return word;
    
    // Post-process to join silent e or endings
    // e.g., 'mak', 'e' -> 'make'
    let res = [];
    for(let i=0; i<chunks.length; i++) {
        res.push(chunks[i]);
    }
    
    // Merge tiny last chunks usually (like silent e)
    // If last chunk is just 'e' and prev chunk ends in consonant
    if(res.length > 1) {
       const last = res[res.length-1];
       if(last === 'e' || last === 'es') {
           res[res.length-2] += res.pop();
       }
    }
    
    return res.join(' Â· ');
}


function getAll(store) { return new Promise((r) => { const req = store.getAll(); req.onsuccess = () => r(req.result); }); }
function addToWrongBank(word) { 
  const tx = db.transaction('wrongBank', 'readwrite'); 
  tx.objectStore('wrongBank').put({ word: word, lastWrong: new Date().toISOString() }); 
}
function removeFromWrongBank(word) { 
  const tx = db.transaction('wrongBank', 'readwrite'); 
  tx.objectStore('wrongBank').delete(word); 
}
function speak(text) {
  speechSynthesis.cancel();
  const u = new SpeechSynthesisUtterance(text); u.lang = 'en-US'; u.rate = 0.9;
  const allVoices = speechSynthesis.getVoices();
  const preferred = allVoices.find(v => v.name === 'Daniel') || allVoices.find(v => v.name === 'Samantha') || allVoices.find(v => v.lang.includes('en'));
  if(preferred) u.voice = preferred;
  speechSynthesis.speak(u);
}
speechSynthesis.onvoiceschanged = () => { };
</script>
</body>
</html>
